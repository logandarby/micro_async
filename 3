use core::{
    pin::Pin,
    sync::atomic::{AtomicBool, AtomicU32, Ordering},
    task::{Context, Poll, Waker},
};

use fugit::{Duration, Instant};
pub type TickInstant = Instant<u64, 1, 32768>;
pub type TickDuration = Duration<u64, 1, 32768>;
use heapless::{BinaryHeap, binary_heap::Min};
use nrf52833_hal::{
    Rtc,
    pac::{NVIC, RTC0, interrupt},
    rtc::{RtcCompareReg, RtcInterrupt},
};
use snafu::prelude::*;

use crate::utils::LockMut;

pub struct Timer {
    end_time: TickInstant,
    state: TimerState,
}

impl Timer {
    pub fn new(duration: TickDuration) -> Self {
        let end_time = Ticker::now() + duration;
        Self {
            end_time,
            state: TimerState::Init,
        }
    }

    fn is_ready(&self) -> bool {
        Ticker::now() >= self.end_time
    }

    pub async fn delay(duration: TickDuration) {
        Self::new(duration).await;
    }
}

enum TimerState {
    Wait,
    Init,
}

impl Future for Timer {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        match self.state {
            TimerState::Init => {
                Ticker::add_deadline(self.end_time, cx.waker()).unwrap();
                self.state = TimerState::Wait;
                Poll::Pending
            }
            TimerState::Wait => {
                if self.is_ready() {
                    Poll::Ready(())
                } else {
                    Poll::Pending
                }
            }
        }
    }
}

static TICKER: LockMut<Ticker> = LockMut::new();

#[derive(Debug)]
struct Deadline {
    value: u64,
    waker: Waker,
}

impl Eq for Deadline {}

impl PartialEq for Deadline {
    fn eq(&self, other: &Self) -> bool {
        self.value == other.value
    }
}

impl PartialOrd for Deadline {
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        self.value.partial_cmp(&other.value)
    }
}

impl Ord for Deadline {
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        self.value.cmp(&other.value)
    }
}

const DEADLINE_MAX_ITEMS: usize = 10;

type DeadlinePQ = BinaryHeap<Deadline, Min, DEADLINE_MAX_ITEMS>;

pub struct Ticker {
    rtc0: Rtc<RTC0>,
    overflow_count: u32,
    deadlines: DeadlinePQ,
}

#[derive(Debug, Snafu)]
pub enum TimerError {
    #[snafu(display("The deadline {ticks} is too big for the internal counter"))]
    DeadlineTooLarge { ticks: u64 },
    #[snafu(display("The deadline queue is full. It has a max of {DEADLINE_MAX_ITEMS} items."))]
    TimerQueueFull,
}

impl Ticker {
    pub fn init(rtc0: RTC0, nvic: &mut NVIC) {
        // SAFETY: Can never return an error since prescalar 0 never returns an error
        #[allow(clippy::unwrap_used)]
        let mut rtc0 = Rtc::new(rtc0, 0).unwrap();
        rtc0.enable_counter();

        // Enable overflow interrupt
        rtc0.enable_event(RtcInterrupt::Overflow);
        rtc0.enable_interrupt(RtcInterrupt::Overflow, Some(nvic));

        // Enable compare interrupt
        rtc0.enable_event(RtcInterrupt::Compare0);
        rtc0.enable_interrupt(RtcInterrupt::Compare0, Some(nvic));

        // Init
        TICKER.init(Ticker {
            overflow_count: 0,
            rtc0,
            deadlines: BinaryHeap::new(),
        });
    }

    pub fn now() -> TickInstant {
        let ticks = TICKER.with_lock(|ticker| {
            let counter = ticker.rtc0.get_counter();
            let overflow = ticker.overflow_count;
            (u64::from(overflow) << 24) | u64::from(counter)
        });
        TickInstant::from_ticks(ticks)
    }

    fn add_deadline(deadline: TickInstant, waker: &Waker) -> Result<(), TimerError> {
        let deadline_ticks = deadline.ticks();
        TICKER.with_lock(|ticker| {
            ticker
                .deadlines
                .push(Deadline {
                    waker: waker.clone(),
                    value: deadline_ticks,
                })
                .map_err(|_| TimerError::TimerQueueFull)?;
            let latest = ticker.deadlines.peek().unwrap();
            set_deadline(latest, &mut ticker.rtc0);
            Ok(())
        })
    }
}

fn set_deadline(deadline: &Deadline, rtc0: &mut Rtc<RTC0>) {
    let deadline_low = (deadline.value & 0x00FF_FFFF) as u32;
    rtc0.set_compare(RtcCompareReg::Compare0, deadline_low)
        .unwrap();
}

#[interrupt]
fn RTC0() {
    TICKER.with_lock(handle_rtc0_interrupt);
}

fn handle_rtc0_interrupt(ticker: &mut Ticker) {
    let rtc0 = ticker.rtc0;
    if rtc0.is_event_triggered(RtcInterrupt::Overflow) {
        rtc0.reset_event(RtcInterrupt::Overflow);
        ticker.overflow_count += 1;
    }
    if rtc0.is_event_triggered(RtcInterrupt::Compare0) {
        rtc0.reset_event(RtcInterrupt::Compare0);
        let latest = ticker
            .deadlines
            .pop()
            .expect("No deadline available on interrupt");
        if let Some(pending_deadline) = deadlines.peek() {
            set_deadline(pending_deadline, &mut rtc0);
        }
        latest.waker.wake();
    }
}
